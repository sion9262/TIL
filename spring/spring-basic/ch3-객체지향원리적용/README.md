#객체지향 원리 적용

## 새로운 할인 정책 개발
"새로운 할인 정책을 확장해보자."

사업주 - 서비스 오픈 직전 할인 정책을 변경하고 싶어요!!  
개발자 - ..... 하긴 하는데..... 처음에 제가 말씀드렸잖아요!  
사업주 - 애자일 소프트웨어 개발 선언 몰라요? 계획을 따르기보다 변화에 대응하기를..  

애자일 소프트웨어 개발 선언 https://agilemanifesto.org/iso/ko/manifesto.html

## 새로운 할인 정책 적용

... 생략

## 문제점

- 우리는 역할과 구현을 충실하게 분리했다. OK
- 다형성도 활용하고, 인터페이스와 구현 객체를 분리했다. OK
- OCP, DIP 같은 객체지향 설계 원칙을 충실히 준수했다
    - 그렇게 보이지만 사실은 아니다.
- DIP: 주문서비스 클라이언트( OrderServiceImpl )는 DiscountPolicy 인터페이스에 의존하면서 DIP를
지킨 것 같은데?
- 클래스 의존관계를 분석해 보자. 추상(인터페이스) 뿐만 아니라 구체(구현) 클래스에도 의존하고
있다.
- 추상(인터페이스) 의존: DiscountPolicy
- 구체(구현) 클래스: FixDiscountPolicy , RateDiscountPolicy
- OCP: 변경하지 않고 확장할 수 있다고 했는데!
    - 지금 코드는 기능을 확장해서 변경하면, 클라이언트 코드에 영향을 준다! 따라서 OCP를 위반한다
    
-> 인터페이스에만 의존하도록 설계해야한다.

## 해결방법

```java
private DiscountPolicy discountPolicy;
```
-> NullPointExecption !!

- 누군가 클라이언트인 OrderServieImpl에 DiscountPolicy의 구현 객체를 대신 생성하고 주입해야한다.

- 기존 방식은 클라이언트인 `OrderServiceImpl`에서 `FixDiscountPolicy`객체를 생성하여 사용함.`
- 하지만 이 방식은 `DiscountPolicy`, `FixDiscountPolicy` 둘 다 의존하여 DIP 위반임.
  - 줄리엣이 연기도하고 캐스팅도 하는 상황
- 이러한 문제를 해결하기위하여 캐스팅을 담당하는 별도의 기획자를 섭외 `AppCofing`
- `AppCofing` 에서 구현 객체를 생성하고 연결하는 책임을 담당함.
- 따라서 `OrderServiceImpl`은 필요한 인터페이스만 선언하면 생성자를 통해 `AppCofing`에서 객체를 전달해줌.
- 이러한 것을 `의존성 주입` 이라함
- 할인 정책을 변경해도 `AppCofing`의 값만 변경하면 됨. 사용 영역, 클라이언트 영역 코드를 변경하지 않아도 됨.

## 정리

이러한 과정 속에서 SRP, DIP, OCP가 적용됨.

1. SRP 단일 책임 원칙 (한 클래스는 하나의 책임만 가져야한다.)
- 클라이언트가 직접 구현 객체를 생성하고 연결하고 실행하는 다양한 책임을 가지고 있었음.
- `AppCofig`로 기능을 분리하여 클라이언트는 실행하는 책임만 담당하게 변경
2. DIP 의존관계 역전 원칙 (추상화에 의존해야지, 구체화에 의존하면 안된다.)
- 클라이언트에서 직접적인 생성으로 인해 추상화인 `DiscountPolicy`도 의존하고 구체화인 `FixDiscountPolicy`도 의존함.
- 클라이언트를 `DiscountPolicy`에만 의존하게 하였지만, 인터페이스만으로는 아무것도 실행 불가.
- `AppConfig`를 통해 필요한 객체 인스턴스를 생성하여 주입하여 해결

3. OCP (소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야한다.)
- 다형성 사용하고 클라이언트가 DIP를 지킴
- 애플리케이션을 사용 영역과 구성 영역으로 나누어 코드 변경없이 사용가능.

## 제어의 역전 IoC
- 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고 연결하고 사용함.
- 하지만 `AppConfig`같이 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전이라 한다.
- 프레임워크 vs 라이브러리
  - 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크가 맞다. (JUnit)
  - 반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니라 라이브러리다.

## 의존관계 주입 DI
- 의존관계는 `정적인 클래스 의존 관계와', `실행 시점에 결정되는 동적인 객체 의존 관계` 둘로 나뉜다.
- 정적인 클래스 의존관계
  - 클래스가 사용하는 `import` 코드만 보고 의존관계를 판단. 애플리케이션을 실행하지 않아도 분석할 수 있다.
  - 하지만 실제 어떤 객체가 주입되는지는 알 수 없다.
- 동적인 객체 인스턴스 의존관계
  - 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계다.
- 애플리케이션 실행 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 의존관계 주입이라 한다.
- 객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다.

## IoC 컨테이너, DI컨테이너
- `AppConfig` 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC or DI 컨테이너라고 한다.
- 또는 어샘블러, 오브젝트 팩토리 등으로 불린다.